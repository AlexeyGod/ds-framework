<?php
/**
 * Created by Digital-Solution.Ru web-studio.
 * https://digital-solution.ru
 * support@digital-solution.ru
 */

namespace framework\components\rbac;


use framework\components\db\ActiveRecord;
use framework\components\db\SqlBuilder;
use framework\core\Application;
use framework\exceptions\ErrorException;
use framework\helpers\ArrayHelper;

class AcceptObject extends ActiveRecord
{
    // Типы объектов
    const TYPE_ROLE = 'role';
    const TYPE_PERMISSION = 'permission';

    // Таблица отношений
    const RBAC_RELATION_TABLE = 'rbac_relations';

    // Типы связей
    const RELATION_OBJECTS = 1;
    const RELATION_USER = 2;
   
    public function attributeLabels()
    {
        return array_merge(['slug' => 'Метка', 'name' => 'Название', 'description' => 'Описание', 'type' => 'Тип объекта'], parent::attributeLabels()); // TODO: Change the autogenerated stub
    }

    public function rules()
    {
        return [
            [$this->getFields(), 'safe']
        ];
    }

    public static function getTypes()
    {
        return [
            self::TYPE_ROLE => 'Роль',
            self::TYPE_PERMISSION => 'Полномочие',
        ];
    }


    // Подгрузка всех привязок объекта к другим объектам
    public function getRelations()
    {
        $sql = new SqlBuilder();
        $sql->select(self::RBAC_RELATION_TABLE)
            ->join([AcceptObject::tableName() => 'ao'], ['ao.id' => 'object2'])
            ->where([
                ['object1' => $this->getIdentity()],
                ['relation' => self::RELATION_OBJECTS],
            ]);

        $data = $sql->row();

        if(empty($data)) return [];
        else
        {
            $relations = [];

            foreach($data as $item)
            {
                $relations[$item['id']] = $item['slug'];
            }

            return $relations;
        }
    }

    public function updateRelations($arrayIdObjects = [])
    {
        if(empty($arrayIdObjects) OR !$arrayIdObjects)
        {
            Application::app()->request->setFlash('warning', 'deleted all relations from object');
            // Удаляем все
            $addSQL = new SqlBuilder();
            $addSQL->delete(static::RBAC_RELATION_TABLE)->where([
                ['object1' => $this->getIdentity()],
                ['relation' => static::RELATION_OBJECTS]
            ]);
            //exit($addSQL->build().' | '.var_export($addSQL->getParams(), true));

            $addSQL->execute();

            return true;
        }

        // Текущие привязки
        $currentRelations = $this->getRelations();

        foreach ($arrayIdObjects as $idObject)
        {
            if(isset($currentRelations[$idObject]))
            {
                unset($currentRelations[$idObject]);
                continue;
            }

            // Добавляем
            $addSQL = new SqlBuilder();
            $addSQL->insert(static::RBAC_RELATION_TABLE)->set([
                'object1' => $this->getIdentity(),
                'object2' => $idObject,
                'relation' => static::RELATION_OBJECTS
            ])->execute();
        }

        // Удаляем оставшиеся
        if(!empty($currentRelations))
            foreach($currentRelations as $relationKey => $relationSlug)
            {
                $addSQL = new SqlBuilder();
                $addSQL->delete(static::RBAC_RELATION_TABLE)->where([
                    ['object1' => $this->getIdentity()],
                    ['object2' => $relationKey],
                    ['relation' => static::RELATION_OBJECTS]
                ]);
                //exit($addSQL->build());
                $addSQL->execute();
            }

        return true;
    }


/* ------------------------- Статические свойства ----------------------------------------- */
    // Все объекты и полномочия в виде массива
    public static function allObjects()
    {
        $data = static::find()->orderBy(['type' => 'desc'])->all();

        foreach ($data as $item)
        {
            $result[$item->id] = static::getTypes()[$item->type].': '.$item->name;
        }

        return $result;
    }

    // Проверка существования объекта полномочий
    public static function accept_exists($slug)
    {
         $check = static::findOne(['slug' => $slug]);
        if($check != null) return true;
        else
            return false;
    }

    // Добавить Объект полномочий
    public static function addAcceptObject($slug, $name, $descr, $objectType)
    {
        // Проверка на существование
        if(!static::accept_exists($slug)) {
            // Создаем объект полномочий
            $object = new static();
            $object->slug = $slug;
            $object->name = $name;
            $object->description = $descr;
            $object->type = $objectType;
            $object->save();

            return $object;
        }
        else
        {
            return false;
            //throw new ErrorException("Ошибка добавления роли/полномочия. Метка ".$slug." уже существует");
        }
    }

    // Добавить роль
    public static function addRole($slug, $name, $descr=''){
        return static::addAcceptObject($slug, $name, $descr, static::TYPE_ROLE);
    }

      // Добавить полномочие
     public static function addPermission($slug, $name, $descr=''){
        return static::addAcceptObject($slug, $name, $descr, static::TYPE_PERMISSION);
    }

    // Добавить связь
    public static function addRelation($object1, $object2, $relationType) // обект 1,2, вид связи
    {
        // Текущие связи по умолчанию
        $currentRelations = [];

        // Загрузка связей первого объекта
        $sql = new SqlBuilder();
        $sql->select(static::RBAC_RELATION_TABLE)
            ->join([AcceptObject::tableName() => 'ao'], ['ao.id' => 'object2'])
            ->where([
                ['object1' => $object1],
                ['relation' => $relationType],
                ]);
        //exit($sql->build());

        $data = $sql->row();

        if(!empty($data))
        {
           // // При существовании связей формируем их массив вида ключ(ID) => занчение (SLUG)
           // if(!empty($data))
           //     foreach ($data as $item)
           //     {
           //         $relations[$item['id']] = $item['slug'];
           //     }

            //exit("Data: ".var_export($relations, true));
            exit("Data: ".var_export($data, true));

            exit("Не обработано в ".__FILE__.", строка ".__LINE__);
        }

        // проверяем содержит ли связь
        if(in_array($object2, $currentRelations)) return true; // Уже содержит
        else
        {
            // Добавляем
            $addSQL = new SqlBuilder();
            $addSQL->insert(static::RBAC_RELATION_TABLE)->set([
                    'object1' => $object1,
                    'object2' => $object2,
                    'relation' => $relationType
                ])->execute();
            return true;
        }
    }

    public static function getObjectRelations($id_object)
    {
        $sql = new SqlBuilder();
        // Загрузка явно привязанных объектов
        $data = $sql->select(self::RBAC_RELATION_TABLE)
            ->fields('object2, names.slug')
            ->join([self::tableName() => 'names'], ['names.id' => 'object2'])
            ->where([
                ['object1' => $id_object],
                ['relation' => static::RELATION_OBJECTS]
            ])
            ->row();
        if(!empty($data))
        {
            // Перебор явно привязанных строк
            foreach($data as $item)
                $return[$item['object2']] = $item['slug'];

            return $return;

        }
        else
            return [];

    }


    public static function getUserAccepts($idUser)
    {
        $sql = new SqlBuilder();

        // Загрузка явно привязанных объектов
        $data = $sql->select(self::RBAC_RELATION_TABLE)
            ->fields('object2, names.slug')
            ->join([self::tableName() => 'names'], ['names.id' => 'object2'])
            ->where([
                ['object1' => $idUser],
                ['relation' => static::RELATION_USER]
            ])
            ->row();

        if(!empty($data))
        {
            // Перебор явно привязанных строк
            foreach($data as $item)
                $return[$item['object2']] = $item['slug'];

            // Загрузка связанных объектов
            foreach ($return as $id_permission => $permission_name)
            {
                $permissions = self::getObjectRelations($id_permission);
                if(count($permissions) > 0)
                {
                    $return = self::mergeAccepts($return, $permissions);
                }
            }

            return $return;
            //exit(var_export($return, true));

            //exit("BREAK IN FILE: ".__FILE__."<br>".var_export($data, true));
        }
        else
            return [];
    }


    public static function updateUserAccepts($idUser, $arrayIdObjects = [])
    {
        if(empty($arrayIdObjects))
        {
            // Удаляем все привязки
            $addSQL = new SqlBuilder();
            $addSQL->delete(static::RBAC_RELATION_TABLE)->where([
                ['object1' => $idUser],
                ['relation' => static::RELATION_USER]
            ]);

            //exit($addSQL->build());
            $addSQL->execute();

            return true;
        }

        // Текущие привязки
        $currentRelations = self::getUserAccepts($idUser, false);

        foreach ($arrayIdObjects as $idObject)
        {
            if(isset($currentRelations[$idObject]))
            {
                unset($currentRelations[$idObject]);
                continue;
            }

            // Добавляем
            $addSQL = new SqlBuilder();
            $addSQL->insert(static::RBAC_RELATION_TABLE)->set([
                'object1' => $idUser,
                'object2' => $idObject,
                'relation' => static::RELATION_USER
            ])->execute();
        }

        // Удаляем оставшиеся
        if(!empty($currentRelations))
            foreach($currentRelations as $relationKey => $relationSlug)
            {
                $addSQL = new SqlBuilder();
                $addSQL->delete(static::RBAC_RELATION_TABLE)->where([
                    ['object1' => $idUser],
                    ['object2' => $relationKey],
                    ['relation' => static::RELATION_USER]
                ]);
                //exit($addSQL->build());
                $addSQL->execute();
            }

        return true;
    }

    public static function mergeAccepts ($acceptsCurrentArray, $newAcceptsArray)
    {
        foreach ($newAcceptsArray as $id_p => $p_name)
        {
            if(!isset($acceptsCurrentArray[$id_p]))
                $acceptsCurrentArray[$id_p] = $p_name;

            $child = self::getObjectRelations($id_p);

            if(count($child) >0) {
                // Вызов рекурсии
                $acceptsCurrentArray = self::mergeAccepts($acceptsCurrentArray, $child);
            }
        }

        return $acceptsCurrentArray;
    }

// Конец класса
}