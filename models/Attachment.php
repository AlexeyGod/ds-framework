<?php
/**
 * Created by Digital-Solution.Ru web-studio.
 * https://digital-solution.ru
 * support@digital-solution.ru
 */

namespace framework\models;


use framework\components\db\ActiveRecord;
use framework\core\Application;
use framework\exceptions\ErrorException;
use framework\helpers\UploadedFile;
use framework\components\db\DataBase;
use framework\helpers\Words;

class Attachment extends ActiveRecord
{
    /*
     Все данные хранятся в таблице "attachments"
    Физически файлы должы быть расположены в "uploads/*" за расположение относительно root/attachments отвечает переменная $_uploadPath

    1) В наследуемом классе должны быть определены
     const PREFIX = 'estimate_';
     protected $_uploadPath = 'uploads/user/photos';

    2) В ActiveForm необходимо передать параметр file

    3) Можно переопределить геттер webPath чтобы задать умолчание, например так:
     public function getWebPath()
    {
        $webPath = parent::getWebPath(); // TODO: Change the autogenerated stub

        if($webPath == '/'.$this->_uploadPath.'/')
            return $webPath.'no-photo.png';
        else
            return $webPath;
    }
     */

    protected $_uploadPath = 'other';


    public $file;

    public static function tableName(){
        return "content_attachments";
    }

    public function __construct(array $options = [])
    {
        if (!is_dir($this->getUploadPath()))
            throw new ErrorException("Ошибка при инициации объекта класса " . $this->modelName() . "(" . static::className() . "). Путь указанный в UploadDir не существует (" . $this->getUploadPath() . ". Создайте нужную папку вручную с правами на чтение и запись)");

        parent::__construct($options);
    }

    public function rules()
    {
        return [
            ['path', 'file', ['targetField' => 'file']],
            [['class', 'extension', 'path'], 'required'],
            [['relation', 'name'], 'safe']
        ];
    }

    public static function find($condition = '')
    {
        return  parent::find($condition)->where(['class' => static::class]); // TODO: Change the autogenerated stub
    }
    public static function findOne($condition = '')
    {
        $parent = parent::find($condition)->where(['class' => static::class]);
        //exit($parent->build().' | '.var_export($parent->getParams(), true));
        return $parent->one();
    }
    public static function findAll($condition = '')
    {
        $parent = parent::find($condition)->where(['class' => static::class]);

        return $parent->all();
    }

    public function attributeLabels()
    {
        return array_merge([
            'name' => 'Название файла',
            'file' => 'Прикрепите файл',
        ], parent::attributeLabels()); // TODO: Change the autogenerated stub
    }

    public function getUploadPath()
    {
        return Application::app()->getRealPath('@root'.'/'.$this->_uploadPath.'/');
    }

    public function getWebPath()
    {
        $uploadedClass = UploadedFile::class;

        if($this->path instanceof $uploadedClass) return '';
        $path = Application::app()->getRealPath($this->_uploadPath).'/'.$this->path;

        if(substr($path, 0, 1) != '/')
            $path = '/'.$path;

        return $path;
    }

    public function getFileName()
    {
        return basename($this->getWebPath());
    }

    public function getClass()
    {
        return static::className();
    }

    public function getIcon()
    {
        $icon = 'icon-file-empty';

        switch($this->extension):
            case 'doc':
            case 'docx':
            case 'docm':
            case 'dotx':
            case 'dot':
            case 'rtf':
                $icon = 'icon-file-word';
                break;

            case 'xlsx':
            case 'xlsm':
            case 'xlsb':
            case 'xltx':
            case 'xltm':
            case 'xls':
            case 'xlt':
            case 'xml':
                $icon = 'icon-file-excel';
                break;

            endswitch;

        return $icon;
    }

   public function delete()
   {
       $filePath = Application::app()->getRealPath('@root/'.$this->getWebPath());

       if(is_file($filePath))
           unlink($filePath);

       return parent::delete(); // TODO: Change the autogenerated stub
   }

    public function upload()
    {
        $this->file = UploadedFile::get($this, 'file');

        if(is_object($this->file) AND $this->file instanceof UploadedFile)
        {
            // Формируем новое имя
            $offset = ((strlen($this->file->extension)+1)*-1);
            $fileName = substr($this->file->name, 0, $offset);
            $fileName = Words::urlTranslit($fileName).'.'.$this->file->extension;
            $newName = static::PREFIX.$this->relation.'_'.date("dmy-his").'_'.$fileName;


            if($this->file->saveAs($this->uploadPath.$newName))
            {
                $this->extension = $this->file->extension;
                $this->path = $newName;
            }
            else
            {
                $this->addError('file', 'Ошибка при сохранении файла в '.$this->uploadPath.$newName);
            }

            return true;
        }
        else
            return false;
    }

    public function beforeSave($changes = [])
    {
        // Умолчания для новой записи
        if($this->isNewRecord)
        {
            $changes['class'] = $this->getClass();
            $changes['author'] = Application::app()->identy->getIdentity();
            $changes['created_at'] = DataBase::current_datetime();
            $changes['updated_at'] = DataBase::current_datetime();
        }

        if(isset($changes['path'])) // Загружен файл
        {
            // Удаляем старый, если есть
            if(!$this->isNewRecord)
            {
                $oldFile = $this->getUploadPath().$this->_oldAttributes['path'];

                if(is_file($oldFile))
                    unlink($oldFile);
            }
        }

        // Фиксируем время изменения
        $changes['updated_at'] = DataBase::current_datetime();

        return parent::beforeSave($changes); // TODO: Change the autogenerated stub
    }

    //public function beforeUpdateQuery($s)
    //{
    //    exit($s->build().'|||'.var_export($s->getParams(), true));
    //}


}